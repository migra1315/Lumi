# Lumi 机器人控制系统重构任务大纲

**任务创建时间**: 2026-01-08
**文档版本**: v1.0
**状态**: 待审核

---

## 一、现状分析

### 1.1 当前架构问题

#### 问题1: RobotController管理职责分散
- **现状**: `RobotControlSystem` 直接持有并管理 `robot_controller` 实例
- **位置**: `RobotControlSystem.py:68, 111-132`
- **问题**:
  - 违反单一职责原则，`RobotControlSystem` 既负责通信又负责机器人控制
  - 对于TASK_CMD类型任务，通过TaskManager调度执行
  - 对于其他命令（JOY_CONTROL_CMD, CHARGE_CMD等），直接在RobotControlSystem中调用robot_controller方法
  - 导致代码逻辑不一致，维护困难

#### 问题2: 命令处理逻辑不统一
- **现状**:
  - TASK_CMD → TaskManager.receive_task_from_cmd() → TaskScheduler队列执行
  - 其他命令 → RobotControlSystem._handle_xxx_command() → 直接调用robot_controller
- **位置**: `RobotControlSystem.py:358-531`
- **问题**:
  - 命令执行方式不一致，部分通过队列调度，部分直接执行
  - 无法统一管理所有命令的执行状态、重试、历史记录
  - 难以实现命令优先级调度
  - 缺乏统一的错误处理和状态上报机制

#### 问题3: 任务状态模型不完整
- **现状**:
  - 只有 `TaskStatus` 用于描述Task类型的巡检任务
  - 其他命令类型（模式切换、充电、摇杆控制等）没有状态跟踪
- **位置**: `dataModels/TaskModels.py:17-24`
- **问题**:
  - 无法追踪非Task类型命令的执行状态
  - 无法实现命令执行历史查询
  - 缺乏失败重试机制

#### 问题4: 数据库设计不完整
- **现状**:
  - 数据库保存：gRPC收发消息、Task任务、站点任务、执行历史
  - 缺少：环境数据历史、非Task命令的执行记录
- **位置**: `task/TaskDatabase.py`
- **问题**:
  - 环境传感器数据没有持久化，无法回溯分析
  - 非Task类型命令没有执行记录，无法审计
  - 缺少系统配置管理表

#### 问题5: 回调机制单向
- **现状**:
  - TaskManager → RobotControlSystem 通过回调传递任务完成/失败事件
  - RobotControlSystem需要主动调用_report_device_data等方法
- **位置**: `RobotControlSystem.py:71-72, 876-895`
- **问题**:
  - TaskManager完成任务后无法自动触发数据上报
  - 需要在多处手动调用上报方法
  - 代码耦合度高

### 1.2 当前代码结构

```
RobotControlSystem
├── robot_controller (直接持有)
├── task_manager
│   ├── robot_controller (传递引用)
│   ├── database
│   └── scheduler
│       └── robot_controller (传递引用)
├── _handle_command()
│   ├── TASK_CMD → TaskManager
│   ├── ROBOT_MODE_CMD → robot_controller (直接调用)
│   ├── JOY_CONTROL_CMD → robot_controller (直接调用)
│   ├── CHARGE_CMD → robot_controller (直接调用)
│   └── 其他命令 → robot_controller (直接调用)
```

---

## 二、改进目标

### 2.1 核心原则
1. **单一职责**: RobotControlSystem专注于通信，TaskManager专注于任务调度和机器人控制
2. **统一调度**: 所有命令类型通过TaskManager统一管理和调度
3. **完整追踪**: 所有命令的执行状态、历史、错误可查询
4. **解耦设计**: 通过回调机制实现模块间通信，降低耦合

### 2.2 目标架构

```
RobotControlSystem (通信层)
├── gRPC通信管理
├── 定期状态上报
└── task_manager (唯一接口)
    ├── robot_controller (完全封装)
    ├── command_queue (统一命令队列)
    ├── database (数据持久化)
    └── scheduler (命令调度执行)
        ├── 执行Task命令
        ├── 执行Mode命令
        ├── 执行Joy命令
        ├── 执行Charge命令
        └── 其他命令
```

### 2.3 具体目标
1. **RobotController管理**: 完全由TaskManager管理，不暴露给RobotControlSystem
2. **统一命令队列**: 所有命令类型通过TaskManager的统一队列调度执行
3. **完整状态模型**: 扩展状态枚举，支持所有命令类型的状态追踪
4. **双向回调机制**: TaskManager完成任务后自动回调RobotControlSystem进行数据上报
5. **完善数据库**: 增加环境数据表、系统配置表，优化现有表结构

---

## 三、实施方案

### 3.1 任务1: 封装RobotController管理

#### 3.1.1 修改TaskManager
**文件**: `task/TaskManager.py`

**变更内容**:
1. TaskManager完全封装robot_controller，不再暴露给外部
2. 新增方法供RobotControlSystem调用：
   ```python
   def get_robot_status(self) -> Dict[str, Any]
   def get_environment_data(self) -> Dict[str, Any]
   def execute_emergency_stop(self) -> bool
   ```
3. 移除外部对robot_controller的直接访问

**影响文件**:
- `RobotControlSystem.py`: 移除robot_controller引用，改用TaskManager提供的方法
- `RobotControlSystem.py:111-132`: 删除_init_robot_controller方法
- `RobotControlSystem.py:577-713`: 修改_report_robot_status和_report_environment_data，通过TaskManager获取数据

#### 3.1.2 修改RobotControlSystem
**文件**: `RobotControlSystem.py`

**变更内容**:
1. 移除robot_controller属性
2. 初始化时传递config给TaskManager，由TaskManager创建robot_controller
3. 所有需要robot数据的地方，通过TaskManager提供的接口获取

**修改位置**:
```python
# 移除
Line 68: self.task_manager = TaskManager(self.robot_controller)
Line 111-132: def _init_robot_controller(self)

# 修改为
Line 68: self.task_manager = TaskManager(self.config, self.use_mock)
```

---

### 3.2 任务2: 统一命令调度队列

#### 3.2.1 设计通用Command模型
**文件**: `dataModels/CommandModels.py` 或 新建 `dataModels/UnifiedCommand.py`

**新增内容**:
```python
class CommandCategory(Enum):
    """命令分类"""
    TASK = "task"              # 巡检任务
    CONTROL = "control"        # 控制命令（mode, joy, charge等）
    CONFIGURATION = "config"   # 配置命令

class CommandStatus(Enum):
    """统一命令状态"""
    PENDING = "pending"
    QUEUED = "queued"          # 已加入队列
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"
    RETRYING = "retrying"

@dataclass
class UnifiedCommand:
    """统一命令模型"""
    command_id: str                    # 命令ID
    cmd_type: CmdType                  # 原始命令类型
    category: CommandCategory          # 命令分类
    priority: int = 5                  # 优先级 (1-10, 1最高)
    data: Any = None                   # 命令数据
    status: CommandStatus = CommandStatus.PENDING
    created_at: datetime = None
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    retry_count: int = 0
    max_retries: int = 3
    error_message: Optional[str] = None
    metadata: Dict[str, Any] = None
```

#### 3.2.2 修改TaskManager - 统一命令队列
**文件**: `task/TaskManager.py`

**新增内容**:
```python
def receive_command(self, command_envelope: CommandEnvelope) -> str:
    """接收并处理所有类型的命令（统一入口）

    Args:
        command_envelope: 命令信封

    Returns:
        str: 命令ID
    """
    # 根据cmd_type创建UnifiedCommand
    # 添加到调度器队列
    # 返回命令ID

def get_command_status(self, command_id: str) -> Dict[str, Any]:
    """查询命令执行状态"""

def cancel_command(self, command_id: str) -> bool:
    """取消命令执行"""
```

**移除/修改内容**:
- 保留 `receive_task_from_cmd` 用于向后兼容，内部调用 `receive_command`
- 移除Task特有的处理逻辑，改为通用命令处理

#### 3.2.3 修改TaskScheduler - 支持多种命令类型
**文件**: `task/TaskScheduler.py`

**变更内容**:
1. 将task_queue改为command_queue，使用优先级队列
2. 修改_execute_task → _execute_command，支持多种命令类型
3. 新增命令类型处理方法：
   ```python
   def _execute_task_command(self, command: UnifiedCommand) -> bool
   def _execute_mode_command(self, command: UnifiedCommand) -> bool
   def _execute_joy_command(self, command: UnifiedCommand) -> bool
   def _execute_charge_command(self, command: UnifiedCommand) -> bool
   def _execute_set_marker_command(self, command: UnifiedCommand) -> bool
   def _execute_position_adjust_command(self, command: UnifiedCommand) -> bool
   ```

**修改位置**:
```python
# Line 20: 修改队列类型
from queue import PriorityQueue
self.command_queue = PriorityQueue()

# Line 56-61: 修改add_task
def add_command(self, command: UnifiedCommand):
    self.command_queue.put((command.priority, command))
    self.database.save_command(command)

# Line 87-124: 修改_execute_task_internal
def _execute_command(self, command: UnifiedCommand) -> bool:
    # 根据cmd_type路由到不同的执行方法
```

#### 3.2.4 修改RobotControlSystem - 统一命令下发
**文件**: `RobotControlSystem.py`

**变更内容**:
1. 简化_handle_command方法，所有命令统一通过TaskManager.receive_command()处理
2. 移除各种_handle_xxx_command方法

**修改位置**:
```python
# Line 329-531: 大幅简化
def _handle_command(self, command_envelope: CommandEnvelope):
    """处理接收到的命令 - 统一通过TaskManager"""
    try:
        # 保存接收消息到数据库
        self.task_manager.database.save_received_message(...)

        # 触发回调
        self._trigger_callback("on_command_received", command_envelope.to_dict())

        # 统一交给TaskManager处理
        command_id = self.task_manager.receive_command(command_envelope)

        self.logger.info(f"命令已提交: {command_id}, 类型: {command_envelope.cmd_type}")

    except Exception as e:
        self.logger.error(f"处理命令失败: {e}")

# 移除Line 380-531的所有_handle_xxx_command方法
```

---

### 3.3 任务3: 扩展状态模型

#### 3.3.1 增强TaskModels.py
**文件**: `dataModels/TaskModels.py`

**新增内容**:
```python
# 已有 TaskStatus (用于Task类型)
# 已有 StationTaskStatus (用于站点任务)

# 新增：通用命令执行状态（在3.2.1中已定义CommandStatus）
```

**注意**:
- 保持TaskStatus和StationTaskStatus用于Task类型任务
- 新的CommandStatus用于统一命令队列
- 兼容性：Task命令也会创建UnifiedCommand，其status映射到CommandStatus

---

### 3.4 任务4: 增加双向回调机制

#### 3.4.1 TaskManager回调RobotControlSystem
**文件**: `task/TaskManager.py`

**新增内容**:
```python
def __init__(self, config, use_mock=True):
    # ... 现有初始化代码

    # 新增：回调函数字典
    self.system_callbacks = {
        "on_command_complete": None,      # 命令完成回调
        "on_command_failed": None,        # 命令失败回调
        "on_data_ready": None,            # 数据准备就绪回调（用于上报）
        "on_arrive_station": None,        # 到达站点回调
    }

def register_system_callback(self, event: str, callback: Callable):
    """注册系统级回调函数

    Args:
        event: 事件名称
        callback: 回调函数
    """
    if event in self.system_callbacks:
        self.system_callbacks[event] = callback
        self.logger.info(f"已注册系统回调: {event}")

def _trigger_system_callback(self, event: str, *args, **kwargs):
    """触发系统级回调"""
    callback = self.system_callbacks.get(event)
    if callback:
        try:
            callback(*args, **kwargs)
        except Exception as e:
            self.logger.error(f"系统回调执行异常: {e}")
```

**修改内容**:
在命令执行完成时触发回调：
```python
def _on_task_complete(self, task: Task):
    """任务完成回调"""
    self.logger.info(f"任务完成: {task.task_id}")

    # 新增：触发系统回调，让RobotControlSystem上报数据
    self._trigger_system_callback(
        "on_data_ready",
        data_type="device_data",
        task=task
    )
```

#### 3.4.2 RobotControlSystem注册回调
**文件**: `RobotControlSystem.py`

**新增内容**:
```python
def __init__(self, config: Dict[str, Any] = None, use_mock: bool = True):
    # ... 现有初始化代码

    # 注册TaskManager回调
    self.task_manager.register_system_callback(
        "on_data_ready",
        self._handle_data_ready_callback
    )
    self.task_manager.register_system_callback(
        "on_arrive_station",
        self._handle_arrive_station_callback
    )

def _handle_data_ready_callback(self, data_type: str, **kwargs):
    """处理TaskManager的数据准备就绪回调"""
    if data_type == "device_data":
        task = kwargs.get("task")
        self._report_device_data(task)
    elif data_type == "environment_data":
        self._report_environment_data()

def _handle_arrive_station_callback(self, station: Station):
    """处理到达站点回调"""
    self._report_arrive_service_point(station)
```

**效果**:
- TaskManager完成任务后自动触发RobotControlSystem上报数据
- 无需在多处手动调用上报方法
- 降低耦合度

---

### 3.5 任务5: 完善数据库设计

#### 3.5.1 新增环境数据表
**文件**: `task/TaskDatabase.py`

**新增表结构**:
```python
# 创建环境数据历史表
cursor.execute('''
    CREATE TABLE IF NOT EXISTS environment_data_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        robot_id TEXT NOT NULL,
        position_x REAL,
        position_y REAL,
        position_theta REAL,
        temperature REAL,
        humidity REAL,
        oxygen REAL,
        carbon_dioxide REAL,
        pm25 REAL,
        pm10 REAL,
        etvoc REAL,
        noise REAL,
        metadata_json TEXT DEFAULT '{}'
    )
''')

# 创建索引提高查询性能
cursor.execute('''
    CREATE INDEX IF NOT EXISTS idx_env_timestamp
    ON environment_data_history(timestamp)
''')
cursor.execute('''
    CREATE INDEX IF NOT EXISTS idx_env_robot_id
    ON environment_data_history(robot_id)
''')
```

**新增方法**:
```python
def save_environment_data(self, robot_id: str, position: Dict, env_data: Dict):
    """保存环境数据"""
    with self._get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO environment_data_history
            (robot_id, position_x, position_y, position_theta,
             temperature, humidity, oxygen, carbon_dioxide,
             pm25, pm10, etvoc, noise)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            robot_id,
            position.get('x', 0.0),
            position.get('y', 0.0),
            position.get('theta', 0.0),
            env_data.get('temperature', 0.0),
            env_data.get('humidity', 0.0),
            env_data.get('oxygen', 0.0),
            env_data.get('carbon_dioxide', 0.0),
            env_data.get('pm25', 0.0),
            env_data.get('pm10', 0.0),
            env_data.get('etvoc', 0.0),
            env_data.get('noise', 0.0)
        ))

def get_environment_data_history(
    self,
    start_time: datetime = None,
    end_time: datetime = None,
    limit: int = 1000
) -> List[Dict[str, Any]]:
    """查询环境数据历史"""
    # 实现查询逻辑
```

#### 3.5.2 新增统一命令表
**文件**: `task/TaskDatabase.py`

**新增表结构**:
```python
# 创建统一命令表
cursor.execute('''
    CREATE TABLE IF NOT EXISTS unified_commands (
        command_id TEXT PRIMARY KEY,
        cmd_type TEXT NOT NULL,
        category TEXT NOT NULL,
        priority INTEGER DEFAULT 5,
        status TEXT DEFAULT 'pending',
        data_json TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        started_at TIMESTAMP,
        completed_at TIMESTAMP,
        retry_count INTEGER DEFAULT 0,
        max_retries INTEGER DEFAULT 3,
        error_message TEXT,
        metadata_json TEXT DEFAULT '{}'
    )
''')

# 创建索引
cursor.execute('''
    CREATE INDEX IF NOT EXISTS idx_cmd_status
    ON unified_commands(status)
''')
cursor.execute('''
    CREATE INDEX IF NOT EXISTS idx_cmd_created
    ON unified_commands(created_at)
''')
```

**新增方法**:
```python
def save_command(self, command: UnifiedCommand):
    """保存统一命令"""

def update_command_status(
    self,
    command_id: str,
    status: CommandStatus,
    error_message: str = None
):
    """更新命令状态"""

def get_command_by_id(self, command_id: str) -> Optional[Dict[str, Any]]:
    """根据ID查询命令"""

def get_commands_by_status(
    self,
    status: CommandStatus,
    limit: int = 100
) -> List[Dict[str, Any]]:
    """根据状态查询命令"""
```

#### 3.5.3 新增系统配置表
**文件**: `task/TaskDatabase.py`

**新增表结构**:
```python
# 创建系统配置表
cursor.execute('''
    CREATE TABLE IF NOT EXISTS system_config (
        config_key TEXT PRIMARY KEY,
        config_value TEXT NOT NULL,
        config_type TEXT DEFAULT 'string',  -- string, int, float, json, bool
        description TEXT,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
''')
```

**新增方法**:
```python
def save_config(self, key: str, value: Any, config_type: str = 'string', description: str = None):
    """保存配置"""

def get_config(self, key: str, default: Any = None) -> Any:
    """获取配置"""

def get_all_configs(self) -> Dict[str, Any]:
    """获取所有配置"""
```

#### 3.5.4 优化现有表结构

**tasks表优化**:
```python
# 添加索引
cursor.execute('''
    CREATE INDEX IF NOT EXISTS idx_task_status
    ON tasks(status)
''')
cursor.execute('''
    CREATE INDEX IF NOT EXISTS idx_task_created
    ON tasks(created_at)
''')
```

**robot_received_messages和robot_sent_messages表优化**:
```python
# 添加索引
cursor.execute('''
    CREATE INDEX IF NOT EXISTS idx_received_processed
    ON robot_received_messages(processed, msg_time)
''')
cursor.execute('''
    CREATE INDEX IF NOT EXISTS idx_sent_status
    ON robot_sent_messages(status, msg_time)
''')
```

---

## 四、实施步骤

### 阶段一: 封装RobotController（估时：2-3小时）
1. 修改TaskManager构造函数，接收config参数并创建robot_controller
2. 在TaskManager中新增get_robot_status()和get_environment_data()方法
3. 修改RobotControlSystem，移除robot_controller引用
4. 修改RobotControlSystem的状态上报方法，通过TaskManager获取数据
5. 测试：确保现有Task任务功能正常

### 阶段二: 设计统一命令模型（估时：2小时）
1. 创建UnifiedCommand数据模型
2. 创建CommandStatus和CommandCategory枚举
3. 在TaskDatabase中新增unified_commands表
4. 实现save_command和update_command_status方法
5. 测试：数据库CRUD操作正常

### 阶段三: 重构TaskScheduler（估时：4-5小时）
1. 将task_queue改为command_queue（PriorityQueue）
2. 修改调度循环，支持UnifiedCommand
3. 实现各种命令类型的执行方法（_execute_mode_command等）
4. 修改回调触发逻辑
5. 测试：各种命令类型能正确执行

### 阶段四: 重构TaskManager（估时：3小时）
1. 实现receive_command()统一入口
2. 实现命令到UnifiedCommand的转换逻辑
3. 兼容性处理：保留receive_task_from_cmd()
4. 实现命令状态查询和取消功能
5. 测试：命令接收、调度、查询功能正常

### 阶段五: 重构RobotControlSystem（估时：2小时）
1. 简化_handle_command方法
2. 移除所有_handle_xxx_command方法
3. 更新回调注册逻辑
4. 测试：gRPC命令接收和处理正常

### 阶段六: 实现双向回调（估时：2小时）
1. 在TaskManager中实现系统回调机制
2. 在RobotControlSystem中注册回调
3. 修改任务完成逻辑，自动触发数据上报
4. 测试：任务完成后自动上报数据

### 阶段七: 完善数据库（估时：3小时）
1. 新增environment_data_history表
2. 新增system_config表
3. 为现有表添加索引
4. 实现数据保存和查询方法
5. 在RobotControlSystem中集成环境数据持久化
6. 测试：数据保存和查询功能正常

### 阶段八: 集成测试与优化（估时：3-4小时）
1. 端到端测试：gRPC命令 → 执行 → 状态上报
2. 测试所有命令类型：Task, Mode, Joy, Charge, SetMarker, PositionAdjust
3. 测试重试机制
4. 测试数据库持久化
5. 性能测试：命令队列吞吐量
6. 优化和bug修复

**总估时**: 21-24小时

---

## 五、关键文件修改清单

### 5.1 核心文件修改

| 文件路径 | 修改类型 | 主要变更 |
|---------|---------|---------|
| `task/TaskManager.py` | 重大重构 | 1. 接管robot_controller管理<br>2. 新增统一命令接收接口<br>3. 新增系统回调机制 |
| `task/TaskScheduler.py` | 重大重构 | 1. 支持UnifiedCommand<br>2. 实现多种命令类型执行<br>3. 优先级队列调度 |
| `task/TaskDatabase.py` | 中等修改 | 1. 新增3个表<br>2. 新增相关CRUD方法<br>3. 优化索引 |
| `RobotControlSystem.py` | 重大重构 | 1. 移除robot_controller<br>2. 简化命令处理逻辑<br>3. 注册TaskManager回调 |
| `dataModels/CommandModels.py` | 小修改 | 1. 新增UnifiedCommand模型<br>2. 新增相关枚举 |
| `dataModels/TaskModels.py` | 小修改 | 1. 保持现有代码<br>2. 确保与UnifiedCommand兼容 |

### 5.2 新增文件

| 文件路径 | 用途 |
|---------|------|
| `dataModels/UnifiedCommand.py` (可选) | 统一命令模型定义 |
| `task/CommandConverter.py` (可选) | 命令转换工具类 |

### 5.3 测试文件

| 文件路径 | 用途 |
|---------|------|
| `tests/test_unified_command.py` | 统一命令模型测试 |
| `tests/test_task_manager_refactor.py` | TaskManager重构测试 |
| `tests/test_command_scheduling.py` | 命令调度测试 |
| `tests/test_database_migration.py` | 数据库迁移测试 |

---

## 六、风险评估与应对

### 6.1 技术风险

| 风险 | 影响 | 概率 | 应对措施 |
|-----|------|------|---------|
| 现有Task任务执行逻辑破坏 | 高 | 中 | 1. 充分的单元测试<br>2. 保留旧接口兼容性<br>3. 分阶段迁移 |
| 命令队列性能问题 | 中 | 低 | 1. 使用优先级队列<br>2. 性能测试<br>3. 必要时优化 |
| 数据库迁移失败 | 高 | 低 | 1. 备份现有数据<br>2. 渐进式创建新表<br>3. 保持向后兼容 |
| gRPC通信中断 | 高 | 低 | 1. 保持现有重连机制<br>2. 命令持久化保证不丢失 |

### 6.2 兼容性策略

1. **向后兼容**: 保留TaskManager.receive_task_from_cmd()方法
2. **数据库兼容**: 新增表不影响现有表，旧代码仍可正常读写
3. **渐进迁移**: 先支持新接口，逐步废弃旧接口
4. **回滚方案**: 保留Git分支，必要时快速回滚

---

## 七、数据库变更详情

### 7.1 新增表

#### unified_commands表
```sql
CREATE TABLE IF NOT EXISTS unified_commands (
    command_id TEXT PRIMARY KEY,
    cmd_type TEXT NOT NULL,
    category TEXT NOT NULL,
    priority INTEGER DEFAULT 5,
    status TEXT DEFAULT 'pending',
    data_json TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    retry_count INTEGER DEFAULT 0,
    max_retries INTEGER DEFAULT 3,
    error_message TEXT,
    metadata_json TEXT DEFAULT '{}'
);

CREATE INDEX idx_cmd_status ON unified_commands(status);
CREATE INDEX idx_cmd_created ON unified_commands(created_at);
```

#### environment_data_history表
```sql
CREATE TABLE IF NOT EXISTS environment_data_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    robot_id TEXT NOT NULL,
    position_x REAL,
    position_y REAL,
    position_theta REAL,
    temperature REAL,
    humidity REAL,
    oxygen REAL,
    carbon_dioxide REAL,
    pm25 REAL,
    pm10 REAL,
    etvoc REAL,
    noise REAL,
    metadata_json TEXT DEFAULT '{}'
);

CREATE INDEX idx_env_timestamp ON environment_data_history(timestamp);
CREATE INDEX idx_env_robot_id ON environment_data_history(robot_id);
```

#### system_config表
```sql
CREATE TABLE IF NOT EXISTS system_config (
    config_key TEXT PRIMARY KEY,
    config_value TEXT NOT NULL,
    config_type TEXT DEFAULT 'string',
    description TEXT,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 7.2 现有表优化

```sql
-- tasks表
CREATE INDEX IF NOT EXISTS idx_task_status ON tasks(status);
CREATE INDEX IF NOT EXISTS idx_task_created ON tasks(created_at);

-- station_tasks表（已有索引，无需修改）

-- robot_received_messages表
CREATE INDEX IF NOT EXISTS idx_received_processed
ON robot_received_messages(processed, msg_time);

-- robot_sent_messages表
CREATE INDEX IF NOT EXISTS idx_sent_status
ON robot_sent_messages(status, msg_time);
```

### 7.3 数据库迁移脚本
建议创建 `database_migration.py` 执行以下操作：
1. 检查当前数据库版本
2. 备份现有数据
3. 创建新表
4. 创建索引
5. 验证迁移结果
6. 记录迁移版本

---

## 八、测试计划

### 8.1 单元测试
- TaskManager.receive_command() 各种命令类型
- TaskScheduler命令执行方法
- Database新增方法
- 回调机制触发

### 8.2 集成测试
- gRPC命令接收 → TaskManager → TaskScheduler → 执行 → 回调 → 数据上报
- 命令优先级调度
- 命令失败重试
- 数据库持久化

### 8.3 性能测试
- 命令队列吞吐量（目标：>100 cmd/s）
- 数据库查询性能
- 内存占用

### 8.4 回归测试
- 现有Task任务执行流程
- gRPC双向流通信
- 环境数据采集

---

## 九、后续优化建议

1. **命令执行日志**: 为所有命令类型添加详细执行日志
2. **Web管理界面**: 开发命令管理和监控界面
3. **命令依赖关系**: 支持命令间的依赖和编排
4. **分布式调度**: 支持多机器人协同任务调度
5. **性能监控**: 添加Prometheus指标导出
6. **配置热更新**: 支持运行时配置更新

---

## 十、审核检查点

请在审核时重点关注以下方面：

### 10.1 架构合理性
- [ ] RobotController封装是否合理
- [ ] 统一命令队列设计是否满足需求
- [ ] 回调机制是否降低了耦合度

### 10.2 实施可行性
- [ ] 各阶段任务是否可独立完成
- [ ] 估时是否合理
- [ ] 是否考虑了兼容性

### 10.3 风险控制
- [ ] 是否有充分的测试计划
- [ ] 是否有回滚方案
- [ ] 是否考虑了性能影响

### 10.4 数据库设计
- [ ] 新增表结构是否合理
- [ ] 索引设计是否优化查询
- [ ] 是否保持向后兼容

### 10.5 补充需求
- [ ] 是否扩展了状态模型
- [ ] 是否实现了TaskManager回调RobotControlSystem
- [ ] 是否完善了数据持久化（gRPC消息、任务状态、环境数据）

---

## 十一、审核意见

**请在此处填写审核意见：**

```
审核人：
审核日期：
审核结果：[ ] 通过  [ ] 需修改  [ ] 拒绝

意见：




```

---

**文档结束**

请审核此大纲，确认无误后我将开始实施重构工作。
