# 站点重试逻辑优化方案

## 文档信息
- **创建时间**: 2026-01-09
- **涉及文件**: `task/TaskScheduler.py`
- **涉及方法**: `_execute_task_internal()`, `_execute_station_task()`, `_retry_station_task()`

---

## 一、当前问题分析

### 1.1 当前代码逻辑

```python
def _execute_task_internal(self, task: Task) -> bool:
    sorted_stations = sorted(task.station_list, key=lambda s: s.station_config.sort)
    try:
        for station in sorted_stations:
            if not self._execute_station_task(station):
                station.status = StationTaskStatus.TO_RETRY
                while not self._retry_station_task(station):  # 问题1: while循环语义不清
                    self.logger.info(f"站点重试失败")
                    time.sleep(1)
        return True  # 问题2: 总是返回True
    except Exception as e:
        return False

def _retry_station_task(self, station: Station):
    if station.retry_count < station.max_retries:
        station.retry_count += 1
        # ... 更新状态和日志 ...
        return self._execute_station_task(station)  # 问题3: 递归调用
    else:
        station.status = StationTaskStatus.FAILED
        station.completed_at = datetime.now()
        return True  # 问题4: 返回True表示退出while循环，但语义混乱
        # ... 注释掉的代码 ...
        return False  # 问题5: 永远不会执行的死代码
```

### 1.2 存在的问题

| 问题ID | 问题描述 | 严重程度 | 影响 |
|--------|---------|---------|------|
| P1 | `while not self._retry_station_task(station)` 循环语义不清晰 | 中 | 代码可读性差，难以维护 |
| P2 | `_execute_task_internal` 总是返回 True，无法反映部分站点失败 | 高 | 任务状态不准确 |
| P3 | `_retry_station_task` 使用递归调用，可能导致栈溢出 | 中 | 大量重试时有风险 |
| P4 | 返回值语义混乱：True 表示"停止重试"而非"成功" | 高 | 代码逻辑难以理解 |
| P5 | 存在永远不会执行的死代码和大量注释代码 | 低 | 代码质量问题 |
| P6 | 站点失败后没有更新数据库状态 | 高 | 数据不一致 |
| P7 | Task 和 Command 级别的状态没有反映部分站点失败 | 高 | 状态报告不准确 |

### 1.3 期望行为

用户期望的行为：
1. **站点失败处理**: 站点执行失败后，自动重试（最多 max_retries 次）
2. **达到最大重试次数**: 将该站点标记为 FAILED，继续执行后续站点
3. **任务状态反映**: Task 级别应能反映部分站点失败的情况
4. **命令状态反映**: Command 级别应能准确描述整体执行结果

---

## 二、设计方案

### 2.1 核心设计思路

**分层状态管理**：
```
Station 状态 → Task 状态 → Command 状态
```

**状态传递规则**：
1. 每个 Station 独立管理自己的状态（COMPLETED / FAILED）
2. Task 状态根据所有 Station 的状态汇总决定
3. Command 状态继承 Task 状态（对于 TASK_CMD 类型）

### 2.2 Station 级别逻辑

#### 2.2.1 执行流程

```
开始执行站点
    ↓
执行站点任务 (_execute_station_task)
    ↓
成功？
    ├─ 是 → 标记 COMPLETED，返回 True
    └─ 否 → 进入重试流程
         ↓
    重试次数 < max_retries？
         ├─ 是 → 增加重试次数，重新执行，循环检查
         └─ 否 → 标记 FAILED，记录失败信息，返回 False
              ↓
         继续执行下一个站点
```

#### 2.2.2 方法设计

**方法1: `_execute_station_task_with_retry(station: Station) -> bool`**
- 功能：执行站点任务，自动处理重试逻辑
- 返回值：True = 站点最终成功，False = 站点最终失败（达到最大重试次数）
- 实现：使用 `for` 循环代替 `while` 循环，更清晰

```python
def _execute_station_task_with_retry(self, station: Station) -> bool:
    """执行站点任务（包含重试逻辑）

    Returns:
        bool: True=站点成功, False=站点失败（达到最大重试次数）
    """
    max_attempts = station.max_retries + 1  # 首次执行 + 重试次数

    for attempt in range(max_attempts):
        if attempt > 0:
            # 这是重试（非首次执行）
            station.retry_count = attempt
            station.status = StationTaskStatus.RETRYING
            self.database.update_station_task_status(station_id, StationTaskStatus.RETRYING)
            self._trigger_callback("on_station_retry", station)
            time.sleep(1)  # 重试间隔

        # 执行站点任务
        if self._execute_station_task(station):
            return True  # 成功

    # 达到最大重试次数，标记为失败
    return self._mark_station_failed(station, "达到最大重试次数")
```

**方法2: `_mark_station_failed(station: Station, reason: str) -> bool`**
- 功能：将站点标记为失败，更新数据库
- 返回值：始终返回 False

```python
def _mark_station_failed(self, station: Station, reason: str) -> bool:
    """将站点标记为失败

    Args:
        station: 站点对象
        reason: 失败原因

    Returns:
        bool: 始终返回 False，表示站点失败
    """
    station_id = station.station_config.station_id
    station.status = StationTaskStatus.FAILED
    station.completed_at = datetime.now()
    station.error_message = reason

    # 更新数据库
    self.database.update_station_task_status(
        station_id,
        StationTaskStatus.FAILED,
        reason
    )

    # 记录失败日志
    self.database.log_task_action(
        self.current_task.task_id,
        station_id,
        "error",
        "failed",
        f"站点执行失败: {reason}"
    )

    self.logger.error(f"站点 {station_id} 执行失败: {reason}")
    return False
```

### 2.3 Task 级别逻辑

#### 2.3.1 状态定义扩展

当前 TaskStatus 枚举可能需要扩展，以支持部分失败状态：

```python
class TaskStatus(Enum):
    PENDING = "pending"           # 待执行
    RUNNING = "running"           # 执行中
    COMPLETED = "completed"       # 全部成功
    PARTIAL_COMPLETED = "partial_completed"  # 部分成功（建议新增）
    FAILED = "failed"             # 全部失败
    CANCELLED = "cancelled"       # 已取消
```

**状态判断逻辑**：
- 所有站点成功 → `COMPLETED`
- 部分站点成功 → `PARTIAL_COMPLETED`
- 所有站点失败 → `FAILED`

#### 2.3.2 Task 执行逻辑

```python
def _execute_task_internal(self, task: Task) -> bool:
    """执行任务内部逻辑

    Returns:
        bool: True=至少有一个站点成功, False=所有站点失败
    """
    sorted_stations = sorted(task.station_list, key=lambda s: s.station_config.sort)

    success_count = 0
    failed_count = 0

    try:
        self.logger.info(f"开始执行任务 {task.task_id}，共 {len(sorted_stations)} 个站点")

        # 执行所有站点任务
        for station in sorted_stations:
            if self._execute_station_task_with_retry(station):
                success_count += 1
                self.logger.info(f"站点 {station.station_config.station_id} 执行成功")
            else:
                failed_count += 1
                self.logger.warning(f"站点 {station.station_config.station_id} 执行失败，继续执行后续站点")

        # 汇总结果
        total = len(sorted_stations)
        self.logger.info(f"任务执行完成: 成功 {success_count}/{total}, 失败 {failed_count}/{total}")

        # 返回值：至少有一个站点成功则返回 True
        return success_count > 0

    except Exception as e:
        self.logger.error(f"任务执行异常: {e}")
        return False
```

#### 2.3.3 Task 状态判断

在 `_command_execution_done()` 或 `_task_execution_done()` 中判断：

```python
def _determine_task_status(self, task: Task) -> TaskStatus:
    """根据站点状态判断任务状态

    Returns:
        TaskStatus: 任务最终状态
    """
    total = len(task.station_list)
    completed = sum(1 for s in task.station_list if s.status == StationTaskStatus.COMPLETED)
    failed = sum(1 for s in task.station_list if s.status == StationTaskStatus.FAILED)

    if completed == total:
        return TaskStatus.COMPLETED
    elif failed == total:
        return TaskStatus.FAILED
    else:
        # 部分成功
        return TaskStatus.PARTIAL_COMPLETED if hasattr(TaskStatus, 'PARTIAL_COMPLETED') else TaskStatus.COMPLETED
```

### 2.4 Command 级别逻辑

#### 2.4.1 状态映射

对于 `TASK_CMD` 类型的 Command：

| Task 状态 | Command 状态 | 说明 |
|----------|-------------|------|
| COMPLETED | COMPLETED | 所有站点成功 |
| PARTIAL_COMPLETED | COMPLETED | 部分站点成功（视为完成，但需记录详情） |
| FAILED | FAILED | 所有站点失败 |

#### 2.4.2 详细信息记录

使用 `command.metadata` 记录详细信息：

```python
command.metadata.update({
    "total_stations": len(task.station_list),
    "success_stations": success_count,
    "failed_stations": failed_count,
    "failed_station_ids": [s.station_config.station_id for s in task.station_list if s.status == StationTaskStatus.FAILED]
})
```

使用 `command.error_message` 记录失败信息：

```python
if failed_count > 0:
    command.error_message = f"任务部分失败: {success_count}/{total} 个站点成功, {failed_count} 个站点失败"
```

---

## 三、实现步骤

### 3.1 阶段一：重构站点重试逻辑

**步骤**：
1. 新增 `_execute_station_task_with_retry()` 方法
2. 新增 `_mark_station_failed()` 方法
3. 修改 `_execute_task_internal()` 调用新方法
4. 删除 `_retry_station_task()` 方法（或标记为废弃）
5. 清理注释代码和死代码

**文件**: `task/TaskScheduler.py`

### 3.2 阶段二：完善 Task 状态判断

**步骤**：
1. （可选）在 `TaskModels.py` 中添加 `PARTIAL_COMPLETED` 状态
2. 在 `_execute_task_internal()` 中统计站点成功/失败数量
3. 新增 `_determine_task_status()` 方法
4. 在任务完成回调中使用新的状态判断逻辑

**文件**:
- `dataModels/TaskModels.py`
- `task/TaskScheduler.py`

### 3.3 阶段三：完善 Command 状态和元数据

**步骤**：
1. 在 `_command_execution_done()` 中更新 command.metadata
2. 根据 task 状态设置 command.error_message
3. 更新数据库记录

**文件**: `task/TaskScheduler.py`

---

## 四、代码实现示例

### 4.1 核心方法实现

#### 方法1: `_execute_station_task_with_retry()`

```python
def _execute_station_task_with_retry(self, station: Station) -> bool:
    """执行站点任务（包含自动重试逻辑）

    功能：
    1. 首次执行站点任务
    2. 如果失败，自动重试（最多 max_retries 次）
    3. 达到最大重试次数后，标记为失败

    Args:
        station: 站点对象

    Returns:
        bool: True=站点最终成功, False=站点最终失败
    """
    station_id = station.station_config.station_id
    max_attempts = station.max_retries + 1  # 首次执行 + 重试次数

    for attempt in range(max_attempts):
        # 判断是否为重试
        if attempt > 0:
            station.retry_count = attempt
            station.status = StationTaskStatus.RETRYING
            self.database.add_station_retry_count(station_id)
            self.database.update_station_task_status(station_id, StationTaskStatus.RETRYING)

            # 记录重试日志
            self.database.log_task_action(
                self.current_task.task_id,
                station_id,
                "retry",
                "retrying",
                f"站点执行重试, 第 {attempt}/{station.max_retries} 次重试"
            )

            # 触发站点重试回调
            self._trigger_callback("on_station_retry", station)

            self.logger.info(f"站点 {station_id} 第 {attempt} 次重试")
            time.sleep(1)  # 重试间隔

        # 执行站点任务
        if self._execute_station_task(station):
            # 成功
            if attempt > 0:
                self.logger.info(f"站点 {station_id} 重试成功（第 {attempt} 次重试）")
            return True

    # 达到最大重试次数，仍然失败
    return self._mark_station_failed(
        station,
        f"达到最大重试次数 ({station.max_retries})"
    )
```

#### 方法2: `_mark_station_failed()`

```python
def _mark_station_failed(self, station: Station, reason: str) -> bool:
    """将站点标记为失败，并更新数据库

    Args:
        station: 站点对象
        reason: 失败原因描述

    Returns:
        bool: 始终返回 False，表示站点失败
    """
    station_id = station.station_config.station_id

    # 更新站点状态
    station.status = StationTaskStatus.FAILED
    station.completed_at = datetime.now()
    station.error_message = reason

    # 更新数据库状态
    self.database.update_station_task_status(
        station_id,
        StationTaskStatus.FAILED,
        reason
    )

    # 记录失败日志
    self.database.log_task_action(
        self.current_task.task_id,
        station_id,
        "error",
        "failed",
        f"站点执行失败: {reason}"
    )

    self.logger.error(f"站点 {station_id} 最终失败: {reason}")

    # 返回 False 表示站点失败
    return False
```

#### 方法3: 重构 `_execute_task_internal()`

```python
def _execute_task_internal(self, task: Task) -> bool:
    """执行任务内部逻辑（重构版）

    改进：
    1. 清晰的循环逻辑（for 循环代替 while 循环）
    2. 统计站点成功/失败数量
    3. 返回值语义明确：True=至少一个站点成功, False=所有站点失败

    Args:
        task: 任务对象

    Returns:
        bool: True=至少有一个站点成功, False=所有站点失败或异常
    """
    # 按照 sort 顺序排序站点
    sorted_stations = sorted(task.station_list, key=lambda s: s.station_config.sort)
    total_stations = len(sorted_stations)

    # 统计变量
    success_count = 0
    failed_count = 0

    try:
        self.logger.info(f"开始执行任务 {task.task_id}，共 {total_stations} 个站点")

        # 顺序执行所有站点任务（失败后继续）
        for i, station in enumerate(sorted_stations, 1):
            station_id = station.station_config.station_id
            self.logger.info(f"执行站点 {i}/{total_stations}: {station_id}")

            # 执行站点（包含重试逻辑）
            if self._execute_station_task_with_retry(station):
                success_count += 1
                self.logger.info(f"✓ 站点 {station_id} 执行成功")
            else:
                failed_count += 1
                self.logger.warning(f"✗ 站点 {station_id} 执行失败，继续执行后续站点")

        # 输出汇总日志
        self.logger.info(
            f"任务 {task.task_id} 执行完成: "
            f"成功 {success_count}/{total_stations}, "
            f"失败 {failed_count}/{total_stations}"
        )

        # 返回值：至少有一个站点成功则返回 True
        return success_count > 0

    except Exception as e:
        self.logger.error(f"任务执行异常: {e}")
        return False
```

#### 方法4: 新增 `_determine_task_status()`

```python
def _determine_task_status(self, task: Task) -> TaskStatus:
    """根据站点执行结果判断任务状态

    判断规则：
    - 所有站点成功 → COMPLETED
    - 部分站点成功 → PARTIAL_COMPLETED（如果支持）或 COMPLETED
    - 所有站点失败 → FAILED

    Args:
        task: 任务对象

    Returns:
        TaskStatus: 任务最终状态
    """
    total = len(task.station_list)
    completed = sum(1 for s in task.station_list if s.status == StationTaskStatus.COMPLETED)
    failed = sum(1 for s in task.station_list if s.status == StationTaskStatus.FAILED)

    if completed == total:
        # 所有站点成功
        return TaskStatus.COMPLETED
    elif failed == total:
        # 所有站点失败
        return TaskStatus.FAILED
    else:
        # 部分成功（如果枚举中没有 PARTIAL_COMPLETED，则使用 COMPLETED）
        if hasattr(TaskStatus, 'PARTIAL_COMPLETED'):
            return TaskStatus.PARTIAL_COMPLETED
        else:
            return TaskStatus.COMPLETED
```

#### 方法5: 更新 `_execute_task_command()`

```python
def _execute_task_command(self, command: UnifiedCommand) -> bool:
    """执行Task类型命令（更新版）"""
    task = command.data
    if not isinstance(task, Task):
        self.logger.error(f"命令数据类型错误，期望Task，实际: {type(task)}")
        command.error_message = f"数据类型错误: {type(task)}"
        return False

    # 执行任务
    success = self._execute_task_internal(task)

    # 判断任务状态
    task_status = self._determine_task_status(task)
    task.status = task_status

    # 统计站点结果
    total = len(task.station_list)
    success_count = sum(1 for s in task.station_list if s.status == StationTaskStatus.COMPLETED)
    failed_count = sum(1 for s in task.station_list if s.status == StationTaskStatus.FAILED)

    # 更新 command metadata
    if not command.metadata:
        command.metadata = {}

    command.metadata.update({
        "total_stations": total,
        "success_stations": success_count,
        "failed_stations": failed_count,
        "failed_station_ids": [
            s.station_config.station_id
            for s in task.station_list
            if s.status == StationTaskStatus.FAILED
        ]
    })

    # 设置错误信息
    if failed_count > 0:
        if failed_count == total:
            command.error_message = f"任务失败: 所有 {total} 个站点均执行失败"
        else:
            command.error_message = f"任务部分失败: {success_count}/{total} 个站点成功"

    # 更新数据库中的任务状态
    self.database.update_task_status(task.task_id, task_status)

    # 触发任务完成或失败回调
    if task_status == TaskStatus.COMPLETED or (hasattr(TaskStatus, 'PARTIAL_COMPLETED') and task_status == TaskStatus.PARTIAL_COMPLETED):
        self._trigger_callback("on_task_complete", task)
    else:
        self._trigger_callback("on_task_failed", task)

    return success
```

---

## 五、数据库变更

### 5.1 TaskStatus 枚举扩展（可选）

如果选择新增 `PARTIAL_COMPLETED` 状态，需要更新：

**文件**: `dataModels/TaskModels.py`

```python
class TaskStatus(Enum):
    """任务状态枚举"""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    PARTIAL_COMPLETED = "partial_completed"  # 新增：部分完成
    FAILED = "failed"
    CANCELLED = "cancelled"
```

### 5.2 数据库迁移（如果需要）

如果现有数据库中有 tasks 表，需要考虑兼容性：
- 旧数据的 status 字段不会包含 `partial_completed`
- 新代码应能处理旧状态值

---

## 六、测试方案

### 6.1 单元测试用例

| 测试用例 | 输入 | 期望输出 |
|---------|------|---------|
| TC1: 所有站点成功 | 3个站点，全部执行成功 | Task=COMPLETED, Command=COMPLETED |
| TC2: 部分站点失败 | 3个站点，1个失败（重试后仍失败） | Task=PARTIAL_COMPLETED, Command=COMPLETED |
| TC3: 所有站点失败 | 3个站点，全部失败 | Task=FAILED, Command=FAILED |
| TC4: 站点重试成功 | 1个站点，首次失败，第2次重试成功 | Station=COMPLETED, Task=COMPLETED |
| TC5: 站点达到最大重试 | 1个站点，max_retries=3，4次均失败 | Station=FAILED, retry_count=3 |

### 6.2 集成测试场景

**场景1: 真实任务执行**
- 创建包含5个站点的任务
- 模拟第2和第4个站点失败（Mock 控制器）
- 验证其他站点继续执行
- 验证最终状态为 PARTIAL_COMPLETED

**场景2: 数据库一致性**
- 执行任务
- 查询数据库验证：
  - unified_commands 表中的 status 和 error_message
  - tasks 表中的 status
  - task_history 表中的详细日志

---

## 七、向后兼容性

### 7.1 API 兼容性

| 接口 | 变更 | 兼容性 |
|-----|------|--------|
| `_execute_task_internal()` | 返回值语义变更 | ✅ 向后兼容（内部方法） |
| `_retry_station_task()` | 废弃 | ⚠️ 需要标记为废弃 |
| TaskStatus 枚举 | 新增 PARTIAL_COMPLETED | ✅ 向后兼容（可选） |

### 7.2 数据库兼容性

- 新增状态值不会影响现有数据
- 查询时应处理新旧状态值

---

## 八、风险评估

| 风险 | 概率 | 影响 | 缓解措施 |
|-----|------|------|---------|
| 状态枚举不一致 | 低 | 中 | 充分测试，使用 hasattr 检查 |
| 重试逻辑异常 | 低 | 高 | 添加异常捕获，记录详细日志 |
| 数据库状态不一致 | 中 | 高 | 使用事务，确保原子性更新 |
| 性能影响 | 低 | 低 | for 循环性能优于递归 |

---

## 九、实施计划

### 9.1 时间安排

| 阶段 | 任务 | 预计时间 |
|-----|------|---------|
| 阶段一 | 重构站点重试逻辑 | 2小时 |
| 阶段二 | 完善 Task 状态判断 | 1小时 |
| 阶段三 | 完善 Command 状态和元数据 | 1小时 |
| 测试 | 单元测试 + 集成测试 | 2小时 |
| 总计 | | 6小时 |

### 9.2 验收标准

- [ ] 站点失败后能自动重试
- [ ] 达到最大重试次数后，继续执行后续站点
- [ ] Task 状态能准确反映站点执行情况
- [ ] Command 的 metadata 包含详细的站点统计信息
- [ ] 所有测试用例通过
- [ ] 数据库状态一致
- [ ] 日志记录完整

---

## 十、附录

### 10.1 相关文档

- [回调函数说明文档](./回调函数说明文档.md)
- [CLAUDE.md](../CLAUDE.md)
- [重构完成总结](../重构完成总结.md)

### 10.2 术语表

| 术语 | 定义 |
|-----|------|
| Station | 站点，一个任务包含多个站点 |
| Task | 任务，包含多个站点的执行序列 |
| Command | 命令，统一命令队列中的命令对象 |
| max_retries | 最大重试次数（不包括首次执行） |
| retry_count | 当前重试次数 |
| PARTIAL_COMPLETED | 部分完成状态（部分站点成功） |

---

**文档版本**: v1.0
**作者**: Lumi Development Team
**审核状态**: 待审核
