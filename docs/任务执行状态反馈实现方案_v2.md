# 任务执行状态反馈实现方案 v2.0

## 修订说明

本版本重新梳理了完整的回调链路，明确了每个层级在何时触发什么回调，以及最终发送什么类型的消息到服务器。

---

## 1. 当前回调机制分析

### 1.1 现有回调链路

```
TaskScheduler (触发回调)
    ↓
TaskManager (处理回调 + 触发系统回调)
    ↓
RobotControlSystem (处理系统回调 + 发送gRPC消息)
    ↓
服务器 (接收ClientStreamMessage)
```

### 1.2 TaskScheduler中已定义的回调

**位置**: `task/TaskScheduler.py` 行31-42

```python
self.task_callbacks = {
    "on_task_start": [],          # 任务开始
    "on_task_complete": [],       # 任务完成
    "on_task_failed": [],         # 任务失败
    "on_station_start": [],       # 站点开始
    "on_station_complete": [],    # 站点完成
    "on_station_retry": [],       # 站点重试
    "on_command_complete": [],    # 命令完成 (NEW)
    "on_command_failed": []       # 命令失败 (NEW)
}
```

### 1.3 TaskManager中已注册的回调

**位置**: `task/TaskManager.py` 行36-42

```python
self.scheduler.register_callback("on_task_start", self._on_task_start)
self.scheduler.register_callback("on_task_complete", self._on_task_complete)
self.scheduler.register_callback("on_task_failed", self._on_task_failed)
self.scheduler.register_callback("on_station_start", self._on_station_start)
self.scheduler.register_callback("on_station_complete", self._on_station_complete)
self.scheduler.register_callback("on_station_retry", self._on_station_retry)

# ❌ 缺失：没有注册 on_command_complete 和 on_command_failed
```

### 1.4 TaskManager中已定义的系统回调

**位置**: `task/TaskManager.py` 行44-48

```python
self.system_callbacks = {
    "on_data_ready": None,       # 数据准备就绪（用于上报设备数据）
    "on_arrive_station": None,   # 到达站点
}

# ❌ 缺失：缺少操作结果回调、命令状态变化回调、任务进度回调
```

### 1.5 RobotControlSystem中已注册的系统回调

**位置**: `RobotControlSystem.py` 行67-69

```python
self.task_manager.register_system_callback("on_data_ready", self._handle_data_ready_callback)
self.task_manager.register_system_callback("on_arrive_station", self._handle_arrive_station_callback)

# ❌ 缺失：缺少新增的系统回调注册
```

### 1.6 现有问题总结

| 问题 | 描述 | 影响 |
|------|------|------|
| **问题1** | TaskScheduler触发`on_command_complete/failed`，但TaskManager未注册 | 命令状态无法反馈给上层 |
| **问题2** | 操作结果通过`on_station_complete`反馈，但无法区分操作类型 | 无法单独反馈操作执行结果 |
| **问题3** | 缺少命令状态变化的系统回调 | RobotControlSystem无法发送CommandStatusUpdate消息 |
| **问题4** | 缺少任务进度的系统回调 | RobotControlSystem无法发送TaskProgressUpdate消息 |

---

## 2. 完整回调链路设计

### 2.1 回调链路概览

```
事件触发点                     TaskScheduler回调              TaskManager系统回调           RobotControlSystem发送消息
════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

【命令状态变化】
命令入队                    → (无)                        → (无)                       → (无需反馈入队)
命令开始执行                → (无)                        → on_command_status_change   → CommandStatusUpdate (RUNNING)
命令执行完成                → on_command_complete         → on_command_status_change   → CommandStatusUpdate (COMPLETED)
命令执行失败                → on_command_failed           → on_command_status_change   → CommandStatusUpdate (FAILED)

【任务进度变化】
任务开始                    → on_task_start               → on_task_progress           → TaskProgressUpdate
站点开始                    → on_station_start            → on_task_progress           → TaskProgressUpdate
站点完成                    → on_station_complete         → on_task_progress           → TaskProgressUpdate
站点重试                    → on_station_retry            → on_task_progress           → TaskProgressUpdate
任务完成                    → on_task_complete            → on_task_progress           → TaskProgressUpdate

【操作结果反馈】
操作完成(开门)              → on_station_complete         → on_operation_result        → OperationResult
操作完成(关门)              → on_station_complete         → on_operation_result        → OperationResult
操作完成(拍照)              → on_station_complete         → on_operation_result        → OperationResult
操作完成(服务)              → on_station_complete         → on_operation_result        → OperationResult

【其他事件】
到达站点                    → on_station_start            → on_arrive_station          → ArriveServicePointUpload (clientUpload流)
```

### 2.2 详细说明

#### 2.2.1 命令状态反馈链路

**触发时机**：
- 命令状态从 PENDING → RUNNING
- 命令状态从 RUNNING → COMPLETED/FAILED

**完整流程**：
```python
# TaskScheduler._execute_command()
command.status = CommandStatus.RUNNING  # 状态变化！
self._trigger_callback("on_command_status_change", command)  # 新增触发点
    ↓
# TaskManager._on_command_status_change()  # 新增方法
self._trigger_system_callback("on_command_status_change", command=command)
    ↓
# RobotControlSystem._handle_command_status_callback()  # 新增方法
self._send_command_status_update(command)
    ↓
# 创建ClientStreamMessage并通过serverCommand流发送
client_msg = robot_pb2.ClientStreamMessage(
    command_type=ClientMessageType.COMMAND_STATUS_UPDATE,
    command_status=CommandStatusUpdate(...)
)
server_command_manager.send_message(client_msg)
```

#### 2.2.2 任务进度反馈链路

**触发时机**：
- 任务开始、站点开始、站点完成、站点重试、任务完成

**完整流程**：
```python
# TaskScheduler._execute_station_task()
self._trigger_callback("on_station_start", station)  # 已有
self._trigger_callback("on_station_complete", station)  # 已有
    ↓
# TaskManager._on_station_start() / _on_station_complete()  # 已有
task = self.scheduler.current_task
self._trigger_system_callback("on_task_progress", task=task, station=station)  # 新增
    ↓
# RobotControlSystem._handle_task_progress_callback()  # 新增方法
self._send_task_progress_update(task)
    ↓
# 创建ClientStreamMessage并通过serverCommand流发送
client_msg = robot_pb2.ClientStreamMessage(
    command_type=ClientMessageType.TASK_PROGRESS_UPDATE,
    task_progress=TaskProgressUpdate(...)
)
server_command_manager.send_message(client_msg)
```

#### 2.2.3 操作结果反馈链路

**触发时机**：
- 站点执行操作（OPEN_DOOR, CLOSE_DOOR, CAPTURE, SERVE）完成后

**完整流程**：
```python
# TaskScheduler._execute_station_task()
if operation_config.operation_mode != OperationMode.NONE:
    operation_result = self._execute_operation(operation_config)  # 返回Dict
    station.metadata['operation_result'] = operation_result  # 保存到metadata
    ↓
# TaskScheduler._execute_station_task() (操作完成后)
self._trigger_callback("on_station_complete", station)  # 已有
    ↓
# TaskManager._on_station_complete()  # 修改此方法
operation_result = station.metadata.get('operation_result')
if operation_result:
    operation_data = {
        'task_id': self.scheduler.current_task.task_id,
        'station_id': station.station_config.station_id,
        'operation_mode': station.station_config.operation_config.operation_mode,
        'result': operation_result
    }
    self._trigger_system_callback("on_operation_result", operation_data=operation_data)  # 新增
    ↓
# RobotControlSystem._handle_operation_result_callback()  # 新增方法
self._send_operation_result(operation_data)
    ↓
# 创建ClientStreamMessage并通过serverCommand流发送
client_msg = robot_pb2.ClientStreamMessage(
    command_type=ClientMessageType.OPERATION_RESULT,
    operation_result=OperationResult(
        image_base64=operation_result.get('images', [])  # 仅CAPTURE操作有
    )
)
server_command_manager.send_message(client_msg)
```

---

## 3. 实施方案

### 3.1 Proto定义修改

**文件**: `gRPC/proto/RobotService.proto`

#### 3.1.1 扩展ClientMessageType枚举

```protobuf
enum ClientMessageType {
    HEARTBEAT = 0;
    COMMAND_RESPONSE = 1;
    SET_MARKER_RESPONSE = 2;
    COMMAND_STATUS_UPDATE = 3;    // 新增
    TASK_PROGRESS_UPDATE = 4;     // 新增
    OPERATION_RESULT = 5;         // 新增
}
```

#### 3.1.2 新增CommandStatus枚举

```protobuf
enum CommandStatus {
    COMMAND_STATUS_PENDING = 0;
    COMMAND_STATUS_QUEUED = 1;
    COMMAND_STATUS_RUNNING = 2;
    COMMAND_STATUS_COMPLETED = 3;
    COMMAND_STATUS_FAILED = 4;
    COMMAND_STATUS_CANCELLED = 5;
    COMMAND_STATUS_RETRYING = 6;
}
```

#### 3.1.3 新增OperationStatus枚举

```protobuf
enum OperationStatus {
    OPERATION_STATUS_SUCCESS = 0;
    OPERATION_STATUS_FAILED = 1;
    OPERATION_STATUS_TIMEOUT = 2;
    OPERATION_STATUS_ABORT = 3;
}
```

#### 3.1.4 新增CommandStatusUpdate消息

```protobuf
message CommandStatusUpdate {
    int64 command_id = 1;
    CmdType command_type = 2;
    CommandStatus status = 3;
    string message = 4;
    int64 timestamp = 5;
    int32 retry_count = 6;
}
```

#### 3.1.5 新增TaskProgressUpdate消息

```protobuf
message TaskProgressUpdate {
    int64 task_id = 1;
    string task_name = 2;
    TaskStatus task_status = 3;
    int32 total_stations = 4;
    int32 completed_stations = 5;
    int32 failed_stations = 6;
    int64 current_station_id = 7;
    string current_station_name = 8;
    StationTaskStatus current_station_status = 9;
    string message = 10;
    int64 timestamp = 11;
}
```

#### 3.1.6 新增OperationResult消息

```protobuf
message OperationResult {
    int64 task_id = 1;
    int64 station_id = 2;
    OperationMode operation_mode = 3;
    OperationStatus status = 4;
    string message = 5;
    repeated string image_base64 = 6;  // 图像数据（仅CAPTURE）
    int64 device_id = 7;
    string door_ip = 8;
    int64 timestamp = 9;
    double duration = 10;
}
```

#### 3.1.7 扩展ClientStreamMessage

```protobuf
message ClientStreamMessage {
    int64 command_id = 1;
    int64 command_time = 2;
    ClientMessageType command_type = 3;
    int64 robot_id = 4;
    oneof data_json {
        ServerResponse response_info = 5;
        PositionInfo position_info = 6;
        CommandStatusUpdate command_status = 7;      // 新增
        TaskProgressUpdate task_progress = 8;        // 新增
        OperationResult operation_result = 9;        // 新增
    }
}
```

#### 3.1.8 编译proto文件

```bash
python -m grpc_tools.protoc -I=gRPC/proto --python_out=gRPC --grpc_python_out=gRPC gRPC/proto/RobotService.proto
```

---

### 3.2 RobotController操作方法改造

**文件**: `robot/RobotController.py`

#### 3.2.1 capture() - 拍照操作

**修改位置**: 行677-714（已有框架，需完善实现）

**改造要点**:
- 返回值从 `str` 改为 `Dict[str, Any]`
- 包含: `success`, `images`, `message`, `device_id`, `timestamp`, `duration`

```python
def capture(self, device_id: str) -> Dict[str, Any]:
    """拍照操作 - 采集图像并返回base64编码数据

    Args:
        device_id: 设备ID

    Returns:
        Dict: {
            'success': bool,
            'images': List[str],  # base64图像列表
            'message': str,
            'device_id': str,
            'timestamp': float,
            'duration': float
        }
    """
    try:
        self.logger.info(f"执行拍照操作 - 设备ID: {device_id}")
        start_time = time.time()

        # TODO: 实现实际的相机采集逻辑
        # 方案1: OpenCV采集USB相机
        # 方案2: HTTP请求网络相机
        # 方案3: 调用机械臂相机SDK

        # 示例：模拟拍照
        import base64
        mock_image_data = b"mock_image_bytes"
        img_base64 = base64.b64encode(mock_image_data).decode('utf-8')

        duration = time.time() - start_time

        return {
            'success': True,
            'images': [img_base64],
            'message': f'拍照成功，耗时{duration:.2f}秒',
            'device_id': device_id,
            'timestamp': time.time(),
            'duration': duration
        }

    except Exception as e:
        self.logger.error(f"拍照失败: {e}")
        return {
            'success': False,
            'images': [],
            'message': f'拍照失败: {str(e)}',
            'device_id': device_id,
            'timestamp': time.time(),
            'duration': 0.0
        }
```

#### 3.2.2 open_door() - 开门操作

**修改位置**: 行452-493（已有实现，需改造返回值）

**改造要点**:
- 返回值从 `bool` 改为 `Dict[str, Any]`
- 包含: `success`, `message`, `door_ip`, `timestamp`, `duration`

```python
def open_door(self, door_ip: str) -> Dict[str, Any]:
    """开门操作

    Args:
        door_ip: 门禁IP地址或门ID

    Returns:
        Dict: {
            'success': bool,
            'message': str,
            'door_ip': str,
            'timestamp': float,
            'duration': float
        }
    """
    self.logger.info(f"执行开门操作: {door_ip}")
    self.system_status = SystemStatus.DOOR_OPERATING
    start_time = time.time()

    try:
        # 调用现有的_operate_lab_door方法
        success = self._operate_lab_door(door_ip, close=False)
        duration = time.time() - start_time

        if success:
            self.system_status = SystemStatus.IDLE
            return {
                'success': True,
                'message': f'开门成功，耗时{duration:.2f}秒',
                'door_ip': door_ip,
                'timestamp': time.time(),
                'duration': duration
            }
        else:
            self.system_status = SystemStatus.ERROR
            return {
                'success': False,
                'message': f'开门失败，耗时{duration:.2f}秒',
                'door_ip': door_ip,
                'timestamp': time.time(),
                'duration': duration
            }

    except Exception as e:
        self.logger.error(f"开门操作异常: {e}")
        self.system_status = SystemStatus.ERROR
        return {
            'success': False,
            'message': f'开门异常: {str(e)}',
            'door_ip': door_ip,
            'timestamp': time.time(),
            'duration': time.time() - start_time
        }
```

#### 3.2.3 close_door() - 关门操作

**修改位置**: 行495-533（已有实现，需改造返回值）

**改造方案**: 类似 `open_door()`

#### 3.2.4 serve() - 服务操作

**修改位置**: 无（需新增）

```python
def serve(self, device_id: str) -> Dict[str, Any]:
    """服务操作（如仪表读数、设备检查等）

    Args:
        device_id: 设备ID

    Returns:
        Dict: {
            'success': bool,
            'message': str,
            'device_id': str,
            'data': Dict,  # 服务数据
            'timestamp': float,
            'duration': float
        }
    """
    try:
        self.logger.info(f"执行服务操作: {device_id}")
        start_time = time.time()

        # TODO: 实现具体的服务逻辑
        service_data = {
            'device_status': 'normal',
            'reading_value': 0.0
        }

        duration = time.time() - start_time

        return {
            'success': True,
            'message': f'服务操作完成，耗时{duration:.2f}秒',
            'device_id': device_id,
            'data': service_data,
            'timestamp': time.time(),
            'duration': duration
        }

    except Exception as e:
        self.logger.error(f"服务操作失败: {e}")
        return {
            'success': False,
            'message': f'服务操作失败: {str(e)}',
            'device_id': device_id,
            'data': {},
            'timestamp': time.time(),
            'duration': time.time() - start_time
        }
```

---

### 3.3 TaskScheduler修改

**文件**: `task/TaskScheduler.py`

#### 3.3.1 修改_execute_operation()

**位置**: 行720-736

**修改前**:
```python
def _execute_operation(self, operation_config: OperationConfig) -> bool:
    # 返回bool
```

**修改后**:
```python
def _execute_operation(self, operation_config: OperationConfig) -> Dict[str, Any]:
    """执行特定操作（返回详细结果）"""
    operation_mode = operation_config.operation_mode

    if operation_mode == OperationMode.OPEN_DOOR:
        result = self._open_door(operation_config.door_ip)
    elif operation_mode == OperationMode.CLOSE_DOOR:
        result = self._close_door(operation_config.door_ip)
    elif operation_mode == OperationMode.CAPTURE:
        result = self._capture(operation_config.device_id)
    elif operation_mode == OperationMode.SERVE:
        result = self._serve(operation_config.device_id)
    else:
        result = {
            'success': True,
            'message': f'跳过未知操作: {operation_mode}',
            'timestamp': time.time(),
            'duration': 0.0
        }

    return result
```

#### 3.3.2 修改_capture()等方法

**位置**: 行738-776

**修改前**:
```python
def _capture(self, device_id: str) -> bool:
    return self.robot_controller.capture(device_id)
```

**修改后**:
```python
def _capture(self, device_id: str) -> Dict[str, Any]:
    """捕获操作实现（返回详细结果）"""
    try:
        self.logger.info(f"执行捕获操作: {device_id}")
        result = self.robot_controller.capture(device_id)
        return result
    except Exception as e:
        self.logger.error(f"捕获操作失败: {e}")
        return {
            'success': False,
            'images': [],
            'message': f'捕获操作异常: {str(e)}',
            'device_id': device_id,
            'timestamp': time.time(),
            'duration': 0.0
        }

def _open_door(self, door_ip: str) -> Dict[str, Any]:
    """开门操作实现（返回详细结果）"""
    try:
        self.logger.info(f"执行开门操作: {door_ip}")
        result = self.robot_controller.open_door(door_ip)
        return result
    except Exception as e:
        self.logger.error(f"开门操作失败: {e}")
        return {
            'success': False,
            'message': f'开门操作异常: {str(e)}',
            'door_ip': door_ip,
            'timestamp': time.time(),
            'duration': 0.0
        }

def _close_door(self, door_ip: str) -> Dict[str, Any]:
    """关门操作实现（返回详细结果）"""
    try:
        self.logger.info(f"执行关门操作: {door_ip}")
        result = self.robot_controller.close_door(door_ip)
        return result
    except Exception as e:
        self.logger.error(f"关门操作失败: {e}")
        return {
            'success': False,
            'message': f'关门操作异常: {str(e)}',
            'door_ip': door_ip,
            'timestamp': time.time(),
            'duration': 0.0
        }

def _serve(self, device_id: str) -> Dict[str, Any]:
    """服务操作实现（返回详细结果）"""
    try:
        self.logger.info(f"执行服务操作: {device_id}")
        result = self.robot_controller.serve(device_id)
        return result
    except Exception as e:
        self.logger.error(f"服务操作失败: {e}")
        return {
            'success': False,
            'message': f'服务操作异常: {str(e)}',
            'device_id': device_id,
            'timestamp': time.time(),
            'duration': 0.0
        }
```

#### 3.3.3 修改_execute_station_task()

**位置**: 行445-525

**关键修改**: 保存操作结果到metadata

```python
def _execute_station_task(self, station: Station) -> bool:
    try:
        # ... [前面的AGV、机械臂、外部轴移动代码不变] ...

        # 4. 执行操作模式
        if station.station_config.operation_config.operation_mode != OperationMode.NONE:
            operation_result = self._execute_operation(
                station.station_config.operation_config
            )

            # ===== 新增：保存操作结果到metadata =====
            if not station.metadata:
                station.metadata = {}
            station.metadata['operation_result'] = operation_result
            # ========================================

            # 检查操作是否成功
            if not operation_result.get('success', False):
                self.logger.error(f"操作失败: {operation_result.get('message')}")
                return False

        # ... [后面的状态更新代码不变] ...

        return True

    except Exception as e:
        self.logger.error(f"站点任务执行异常: {e}")
        return False
```

#### 3.3.4 新增命令状态变化触发

**位置**: `_execute_command()` 方法中

```python
def _execute_command(self, command: UnifiedCommand):
    """执行命令（统一入口）"""
    self.current_command = command

    # 更新命令状态为运行中
    command.status = CommandStatus.RUNNING
    command.started_at = datetime.now()
    self.database.update_command_status(command.command_id, CommandStatus.RUNNING)

    # ===== 新增：触发命令状态变化回调 =====
    self._trigger_callback("on_command_status_change", command)
    # ======================================

    self.logger.info(f"开始执行命令: {command.command_id}, 类型: {command.cmd_type.value}")

    # ... [后续代码不变] ...
```

---

### 3.4 TaskManager修改

**文件**: `task/TaskManager.py`

#### 3.4.1 扩展system_callbacks字典

**位置**: 行44-48

**修改前**:
```python
self.system_callbacks = {
    "on_data_ready": None,
    "on_arrive_station": None,
}
```

**修改后**:
```python
self.system_callbacks = {
    "on_data_ready": None,
    "on_arrive_station": None,
    "on_command_status_change": None,   # 新增
    "on_task_progress": None,           # 新增
    "on_operation_result": None,        # 新增
}
```

#### 3.4.2 注册命令级回调

**位置**: 行36-42之后

**新增**:
```python
# 注册调度器回调
self.scheduler.register_callback("on_task_start", self._on_task_start)
self.scheduler.register_callback("on_task_complete", self._on_task_complete)
self.scheduler.register_callback("on_task_failed", self._on_task_failed)
self.scheduler.register_callback("on_station_start", self._on_station_start)
self.scheduler.register_callback("on_station_complete", self._on_station_complete)
self.scheduler.register_callback("on_station_retry", self._on_station_retry)

# ===== 新增：注册命令级回调 =====
self.scheduler.register_callback("on_command_complete", self._on_command_complete)
self.scheduler.register_callback("on_command_failed", self._on_command_failed)
self.scheduler.register_callback("on_command_status_change", self._on_command_status_change)
# =================================
```

#### 3.4.3 新增回调处理方法

**位置**: 行338-384之后

```python
# ==================== 回调函数 ====================

# ... [现有回调方法不变] ...

# ===== 新增：命令级回调处理 =====
def _on_command_complete(self, command):
    """命令完成回调"""
    self.logger.info(f"命令完成: {command.command_id}")

    # 触发系统回调：通知RobotControlSystem命令状态变化
    self._trigger_system_callback(
        "on_command_status_change",
        command=command
    )

def _on_command_failed(self, command):
    """命令失败回调"""
    self.logger.error(f"命令失败: {command.command_id}")

    # 触发系统回调：通知RobotControlSystem命令状态变化
    self._trigger_system_callback(
        "on_command_status_change",
        command=command
    )

def _on_command_status_change(self, command):
    """命令状态变化回调（任何状态变化都触发）"""
    self.logger.info(f"命令状态变化: {command.command_id} -> {command.status.value}")

    # 触发系统回调：通知RobotControlSystem命令状态变化
    self._trigger_system_callback(
        "on_command_status_change",
        command=command
    )
# ================================
```

#### 3.4.4 修改现有回调方法

**位置**: 行360-384

**修改_on_station_start()**:
```python
def _on_station_start(self, station: Station):
    """站点开始回调"""
    self.logger.info(f"站点开始: {station.station_config.station_id}")

    # 触发系统回调：通知RobotControlSystem到达站点
    self._trigger_system_callback(
        "on_arrive_station",
        station=station
    )

    # ===== 新增：触发任务进度回调 =====
    task = self.scheduler.current_task
    if task:
        self._trigger_system_callback(
            "on_task_progress",
            task=task,
            station=station
        )
    # ==================================
```

**修改_on_station_complete()**:
```python
def _on_station_complete(self, station: Station):
    """站点完成回调"""
    self.logger.info(f"站点完成: {station.station_config.station_id}")

    # ===== 新增：检查是否有操作结果，触发操作结果回调 =====
    operation_result = station.metadata.get('operation_result') if station.metadata else None
    if operation_result:
        task = self.scheduler.current_task
        operation_data = {
            'task_id': task.task_id if task else '',
            'station_id': station.station_config.station_id,
            'operation_mode': station.station_config.operation_config.operation_mode,
            'result': operation_result
        }
        self._trigger_system_callback(
            "on_operation_result",
            operation_data=operation_data
        )
    # ========================================================

    # ===== 新增：触发任务进度回调 =====
    task = self.scheduler.current_task
    if task:
        self._trigger_system_callback(
            "on_task_progress",
            task=task,
            station=station
        )
    # ==================================

    # 原有逻辑保留（如果需要）
    # self._trigger_system_callback(
    #     "on_data_ready",
    #     data_type="device_data",
    #     station=station
    # )
```

---

### 3.5 RobotControlSystem修改

**文件**: `RobotControlSystem.py`

#### 3.5.1 注册新的系统回调

**位置**: 行67-69之后

**修改前**:
```python
self.task_manager.register_system_callback("on_data_ready", self._handle_data_ready_callback)
self.task_manager.register_system_callback("on_arrive_station", self._handle_arrive_station_callback)
```

**修改后**:
```python
# 注册TaskManager系统回调
self.task_manager.register_system_callback("on_data_ready", self._handle_data_ready_callback)
self.task_manager.register_system_callback("on_arrive_station", self._handle_arrive_station_callback)

# ===== 新增：注册新的系统回调 =====
self.task_manager.register_system_callback("on_command_status_change", self._handle_command_status_callback)
self.task_manager.register_system_callback("on_task_progress", self._handle_task_progress_callback)
self.task_manager.register_system_callback("on_operation_result", self._handle_operation_result_callback)
# ===================================
```

#### 3.5.2 新增回调处理方法

**位置**: 行658之后

```python
# ==================== 新增回调处理方法 ====================

def _handle_command_status_callback(self, **kwargs):
    """处理命令状态变化回调

    Args:
        **kwargs: 包含command对象
    """
    command = kwargs.get("command")
    if not command:
        return

    try:
        # 发送命令状态更新消息
        self._send_command_status_update(command)
    except Exception as e:
        self.logger.error(f"发送命令状态更新失败: {e}")

def _handle_task_progress_callback(self, **kwargs):
    """处理任务进度回调

    Args:
        **kwargs: 包含task和station对象
    """
    task = kwargs.get("task")
    station = kwargs.get("station")

    if not task:
        return

    try:
        # 发送任务进度更新消息
        self._send_task_progress_update(task, station)
    except Exception as e:
        self.logger.error(f"发送任务进度更新失败: {e}")

def _handle_operation_result_callback(self, **kwargs):
    """处理操作结果回调

    Args:
        **kwargs: 包含operation_data
    """
    operation_data = kwargs.get("operation_data")
    if not operation_data:
        return

    try:
        # 发送操作结果消息
        self._send_operation_result(operation_data)
    except Exception as e:
        self.logger.error(f"发送操作结果失败: {e}")
```

#### 3.5.3 新增消息发送方法

**位置**: 行658之后

```python
# ==================== 新增消息发送方法 ====================

def _send_command_status_update(self, command):
    """发送命令状态更新

    Args:
        command: UnifiedCommand对象
    """
    try:
        from dataModels.CommandModels import CmdType
        from dataModels.UnifiedCommand import CommandStatus
        import gRPC.RobotService_pb2 as robot_pb2

        # 映射命令状态
        status_map = {
            CommandStatus.PENDING: robot_pb2.CommandStatus.COMMAND_STATUS_PENDING,
            CommandStatus.QUEUED: robot_pb2.CommandStatus.COMMAND_STATUS_QUEUED,
            CommandStatus.RUNNING: robot_pb2.CommandStatus.COMMAND_STATUS_RUNNING,
            CommandStatus.COMPLETED: robot_pb2.CommandStatus.COMMAND_STATUS_COMPLETED,
            CommandStatus.FAILED: robot_pb2.CommandStatus.COMMAND_STATUS_FAILED,
            CommandStatus.CANCELLED: robot_pb2.CommandStatus.COMMAND_STATUS_CANCELLED,
            CommandStatus.RETRYING: robot_pb2.CommandStatus.COMMAND_STATUS_RETRYING,
        }

        # 映射命令类型
        cmd_type_map = {
            CmdType.TASK_CMD: robot_pb2.CmdType.TASK_CMD,
            CmdType.ROBOT_MODE_CMD: robot_pb2.CmdType.ROBOT_MODE_CMD,
            CmdType.JOY_CONTROL_CMD: robot_pb2.CmdType.JOY_CONTROL_CMD,
            CmdType.SET_MARKER_CMD: robot_pb2.CmdType.SET_MARKER_CMD,
            CmdType.CHARGE_CMD: robot_pb2.CmdType.CHARGE_CMD,
            CmdType.POSITION_ADJUST_CMD: robot_pb2.CmdType.POSITION_ADJUST_CMD,
            CmdType.RESPONSE_CMD: robot_pb2.CmdType.RESPONSE_CMD,
        }

        # 创建CommandStatusUpdate消息
        status_update = robot_pb2.CommandStatusUpdate(
            command_id=int(command.command_id) if command.command_id.isdigit() else abs(hash(command.command_id)) % (2**31),
            command_type=cmd_type_map.get(command.cmd_type, robot_pb2.CmdType.RESPONSE_CMD),
            status=status_map.get(command.status, robot_pb2.CommandStatus.COMMAND_STATUS_PENDING),
            message=command.error_message or f"命令状态: {command.status.value}",
            timestamp=int(time.time() * 1000),
            retry_count=command.retry_count
        )

        # 创建ClientStreamMessage
        client_msg = robot_pb2.ClientStreamMessage(
            command_id=int(command.command_id) if command.command_id.isdigit() else abs(hash(command.command_id)) % (2**31),
            command_time=int(time.time() * 1000),
            command_type=robot_pb2.ClientMessageType.COMMAND_STATUS_UPDATE,
            robot_id=self.robot_id,
            command_status=status_update
        )

        # 通过serverCommand流发送
        if self.server_command_manager and self.server_command_manager.is_stream_active:
            self.server_command_manager.send_message(client_msg)
            self.logger.info(f"命令状态更新已发送: {command.command_id} -> {command.status.value}")
        else:
            self.logger.warning("serverCommand流未激活，无法发送命令状态更新")

    except Exception as e:
        self.logger.error(f"发送命令状态更新异常: {e}")


def _send_task_progress_update(self, task, station=None):
    """发送任务进度更新

    Args:
        task: Task对象
        station: 当前站点（可选）
    """
    try:
        import gRPC.RobotService_pb2 as robot_pb2
        from dataModels.TaskModels import TaskStatus, StationTaskStatus

        # 统计站点状态
        total_stations = len(task.station_list)
        completed_stations = sum(1 for s in task.station_list if s.status == StationTaskStatus.COMPLETED)
        failed_stations = sum(1 for s in task.station_list if s.status == StationTaskStatus.FAILED)

        # 获取当前站点
        current_station = station or self.task_manager.scheduler.current_station

        # 映射任务状态
        task_status_map = {
            TaskStatus.PENDING: robot_pb2.TaskStatus.TASK_STATUS_PENDING,
            TaskStatus.RUNNING: robot_pb2.TaskStatus.TASK_STATUS_RUNNING,
            TaskStatus.COMPLETED: robot_pb2.TaskStatus.TASK_STATUS_COMPLETED,
            TaskStatus.FAILED: robot_pb2.TaskStatus.TASK_STATUS_FAILED,
            TaskStatus.PARTIAL_COMPLETED: robot_pb2.TaskStatus.TASK_STATUS_COMPLETED,
            TaskStatus.RETRYING: robot_pb2.TaskStatus.TASK_STATUS_RETRYING,
        }

        # 映射站点状态
        station_status_map = {
            StationTaskStatus.PENDING: robot_pb2.StationTaskStatus.STATION_TASK_STATUS_PENDING,
            StationTaskStatus.RUNNING: robot_pb2.StationTaskStatus.STATION_TASK_STATUS_RUNNING,
            StationTaskStatus.COMPLETED: robot_pb2.StationTaskStatus.STATION_TASK_STATUS_COMPLETED,
            StationTaskStatus.FAILED: robot_pb2.StationTaskStatus.STATION_TASK_STATUS_FAILED,
            StationTaskStatus.RETRYING: robot_pb2.StationTaskStatus.STATION_TASK_STATUS_RETRYING,
        }

        # 创建TaskProgressUpdate消息
        progress_update = robot_pb2.TaskProgressUpdate(
            task_id=int(task.task_id),
            task_name=task.task_name,
            task_status=task_status_map.get(task.status, robot_pb2.TaskStatus.TASK_STATUS_PENDING),
            total_stations=total_stations,
            completed_stations=completed_stations,
            failed_stations=failed_stations,
            current_station_id=int(current_station.station_config.station_id) if current_station else 0,
            current_station_name=current_station.station_config.name if current_station else "",
            current_station_status=station_status_map.get(current_station.status, robot_pb2.StationTaskStatus.STATION_TASK_STATUS_PENDING) if current_station else robot_pb2.StationTaskStatus.STATION_TASK_STATUS_PENDING,
            message=f"进度: {completed_stations}/{total_stations}",
            timestamp=int(time.time() * 1000)
        )

        # 创建ClientStreamMessage
        client_msg = robot_pb2.ClientStreamMessage(
            command_id=int(task.task_id),
            command_time=int(time.time() * 1000),
            command_type=robot_pb2.ClientMessageType.TASK_PROGRESS_UPDATE,
            robot_id=self.robot_id,
            task_progress=progress_update
        )

        # 通过serverCommand流发送
        if self.server_command_manager and self.server_command_manager.is_stream_active:
            self.server_command_manager.send_message(client_msg)
            self.logger.info(f"任务进度更新已发送: {task.task_id} - {completed_stations}/{total_stations}")
        else:
            self.logger.warning("serverCommand流未激活，无法发送任务进度更新")

    except Exception as e:
        self.logger.error(f"发送任务进度更新异常: {e}")


def _send_operation_result(self, operation_data: Dict[str, Any]):
    """发送操作结果

    Args:
        operation_data: 操作数据，包含task_id, station_id, operation_mode, result
    """
    try:
        import gRPC.RobotService_pb2 as robot_pb2
        from dataModels.TaskModels import OperationMode

        result = operation_data.get('result', {})
        operation_mode = operation_data.get('operation_mode')

        # 映射操作模式
        operation_mode_map = {
            OperationMode.OPEN_DOOR: robot_pb2.OperationMode.OPERATION_MODE_OPEN_DOOR,
            OperationMode.CLOSE_DOOR: robot_pb2.OperationMode.OPERATION_MODE_CLOSE_DOOR,
            OperationMode.CAPTURE: robot_pb2.OperationMode.OPERATION_MODE_CAPTURE,
            OperationMode.SERVE: robot_pb2.OperationMode.OPERATION_MODE_SERVICE,
            OperationMode.NONE: robot_pb2.OperationMode.OPERATION_MODE_NONE,
        }

        # 映射操作状态
        operation_status = (
            robot_pb2.OperationStatus.OPERATION_STATUS_SUCCESS
            if result.get('success', False)
            else robot_pb2.OperationStatus.OPERATION_STATUS_FAILED
        )

        # 提取device_id和door_ip
        device_id = result.get('device_id', '')
        door_ip = result.get('door_ip', '')

        # 转换device_id为整数（如果是字符串）
        try:
            device_id_int = int(device_id) if device_id else 0
        except (ValueError, TypeError):
            device_id_int = 0

        # 创建OperationResult消息
        operation_result = robot_pb2.OperationResult(
            task_id=int(operation_data.get('task_id', 0)),
            station_id=int(operation_data.get('station_id', 0)),
            operation_mode=operation_mode_map.get(operation_mode, robot_pb2.OperationMode.OPERATION_MODE_NONE),
            status=operation_status,
            message=result.get('message', ''),
            image_base64=result.get('images', []),  # 仅CAPTURE操作有数据
            device_id=device_id_int,
            door_ip=door_ip,
            timestamp=int(result.get('timestamp', time.time()) * 1000),
            duration=result.get('duration', 0.0)
        )

        # 创建ClientStreamMessage
        client_msg = robot_pb2.ClientStreamMessage(
            command_id=int(operation_data.get('task_id', 0)),
            command_time=int(time.time() * 1000),
            command_type=robot_pb2.ClientMessageType.OPERATION_RESULT,
            robot_id=self.robot_id,
            operation_result=operation_result
        )

        # 通过serverCommand流发送
        if self.server_command_manager and self.server_command_manager.is_stream_active:
            self.server_command_manager.send_message(client_msg)
            self.logger.info(f"操作结果已发送: {operation_mode.value} -> {result.get('success')}")
        else:
            self.logger.warning("serverCommand流未激活，无法发送操作结果")

    except Exception as e:
        self.logger.error(f"发送操作结果异常: {e}")
```

---

## 4. 完整实施步骤

### Phase 1: Proto定义修改 ✅

1. 修改 `gRPC/proto/RobotService.proto`
2. 编译proto文件
   ```bash
   python -m grpc_tools.protoc -I=gRPC/proto --python_out=gRPC --grpc_python_out=gRPC gRPC/proto/RobotService.proto
   ```

### Phase 2: RobotController操作实现 ✅

1. 改造 `capture()` 方法（返回Dict）
2. 改造 `open_door()` 方法（返回Dict）
3. 改造 `close_door()` 方法（返回Dict）
4. 新增 `serve()` 方法（返回Dict）

### Phase 3: TaskScheduler修改 ✅

1. 修改 `_execute_operation()` 返回详细结果
2. 修改 `_capture()`, `_open_door()`, `_close_door()`, `_serve()` 方法
3. 修改 `_execute_station_task()` 保存操作结果到metadata
4. 新增命令状态变化触发点

### Phase 4: TaskManager修改 ✅

1. 扩展 `system_callbacks` 字典（新增3个回调）
2. 注册命令级回调（`on_command_complete`, `on_command_failed`, `on_command_status_change`）
3. 新增回调处理方法（3个）
4. 修改现有回调方法（`_on_station_start`, `_on_station_complete`）

### Phase 5: RobotControlSystem修改 ✅

1. 注册新的系统回调（3个）
2. 新增回调处理方法（3个）
3. 新增消息发送方法（3个）

### Phase 6: 测试验证 ✅

1. **单元测试**:
   - 测试操作方法返回值格式
   - 测试proto消息创建和序列化

2. **集成测试**:
   - 使用 `grpc_test_server.py` 发送任务命令
   - 验证机器人执行操作并返回结果
   - 验证服务器接收到完整的反馈消息

3. **端到端测试**:
   - 测试完整的任务执行流程
   - 验证所有状态反馈消息

---

## 5. 回调触发时序图

### 5.1 命令执行完整流程

```
时间轴          TaskScheduler                TaskManager                  RobotControlSystem           服务器
═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════

T0: 命令入队    add_command(cmd)
                  ↓
                command_queue.put()

T1: 命令出队    _scheduler_loop()
                  ↓
                _execute_command(cmd)
                  ↓
                cmd.status = RUNNING
                  ↓
                _trigger_callback(           → _on_command_status_change() → _handle_command_status_callback() → 接收
                "on_command_status_change")     ↓                             ↓                                    CommandStatusUpdate
                                               _trigger_system_callback()   _send_command_status_update()        (RUNNING)
                  ↓
                执行命令...

T2: 任务开始    _execute_task_command()
                  ↓
                _trigger_callback(           → _on_task_start()            → _handle_task_progress_callback()  → 接收
                "on_task_start")                ↓                             ↓                                    TaskProgressUpdate
                                               _trigger_system_callback()   _send_task_progress_update()        (0/5 站点)

T3: 站点开始    _execute_station_task()
                  ↓
                _trigger_callback(           → _on_station_start()         → _handle_task_progress_callback()  → 接收
                "on_station_start")             ↓                             ↓                                    TaskProgressUpdate
                                               _trigger_system_callback()   _send_task_progress_update()        (站点1开始)
                                                 ("on_task_progress")
                                                 ("on_arrive_station")      → _handle_arrive_station_callback() → 接收
                                                                               ↓                                    ArriveServicePointUpload
                                                                             _report_arrive_service_point()       (clientUpload流)

T4: 执行操作    _execute_operation()
                  ↓
                operation_result = {...}
                  ↓
                station.metadata[
                  'operation_result'] = result

T5: 站点完成    _trigger_callback(           → _on_station_complete()      → _handle_operation_result_callback() → 接收
                "on_station_complete")          ↓                             ↓                                      OperationResult
                                               检查operation_result          _send_operation_result()              (含图像数据)
                                               _trigger_system_callback()
                                                 ("on_operation_result")
                                               _trigger_system_callback()   → _handle_task_progress_callback()    → 接收
                                                 ("on_task_progress")          ↓                                      TaskProgressUpdate
                                                                             _send_task_progress_update()          (1/5 站点完成)

T6: 重复T3-T5   执行剩余站点...

T7: 任务完成    _trigger_callback(           → _on_task_complete()         → _handle_task_progress_callback()    → 接收
                "on_task_complete")             ↓                             ↓                                      TaskProgressUpdate
                                               _trigger_system_callback()   _send_task_progress_update()          (5/5 站点完成)

T8: 命令完成    cmd.status = COMPLETED
                  ↓
                _trigger_callback(           → _on_command_complete()       → _handle_command_status_callback()   → 接收
                "on_command_complete")          ↓                             ↓                                      CommandStatusUpdate
                                               _trigger_system_callback()   _send_command_status_update()         (COMPLETED)
```

---

## 6. 注意事项

### 6.1 兼容性
- 保持向后兼容：旧版本不发送新消息类型
- Proto扩展使用新的字段编号
- 服务器端需要同步更新以处理新的消息类型

### 6.2 性能
- 避免过于频繁发送状态更新（可配置发送间隔）
- 图像数据base64编码会增大传输量，考虑压缩或限制图像大小
- 使用异步发送，避免阻塞任务执行

### 6.3 错误处理
- 操作失败时记录详细错误信息
- 消息发送失败时本地记录（已保存到数据库）
- 超时处理：操作超时视为失败

### 6.4 数据一致性
- 操作结果保存到station.metadata，确保数据持久化
- 命令状态更新到数据库，确保可追溯
- 消息发送失败不影响任务执行

---

## 7. 总结

本方案通过**清晰的三层回调机制**实现了完整的任务执行状态反馈：

**回调链路**：
```
TaskScheduler (事件触发)
    ↓ 触发8种回调
TaskManager (回调处理 + 转换)
    ↓ 触发5种系统回调
RobotControlSystem (消息构建 + 发送)
    ↓ 通过serverCommand流发送
服务器 (接收3种反馈消息)
```

**核心改进**：
1. ✅ 明确了每个层级的职责
2. ✅ 梳理了完整的回调触发时机
3. ✅ 规范了操作方法的返回值格式
4. ✅ 统一了消息发送流程

**反馈能力**：
1. ✅ 命令级别：接收确认、执行中、完成、失败
2. ✅ 任务级别：进度更新（当前站点、完成数量）
3. ✅ 操作级别：开门/关门/拍照/服务的执行结果（含图像数据）
